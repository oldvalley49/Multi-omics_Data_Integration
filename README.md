# Benchmarking Algorithms for Multi-omics Single Cell Data Integration Across Unpaired scRNA-seq and scATAC-seq Data.
**Tomoya Furutani**

This repository contains codes and visualizations for benchmarking cross-modality integration across different datasets. Four integration algorithms were evaluated across multiple publicly available datasets. 

## Project Background

Recent advancements in single-cell sequencing technologies have revolutionized biological research; these technologies enable the analysis of cellular heterogeneity and regulatory networks by generating large datasets across various modalities. scRNA-seq provides insights into gene expression by measuring mRNA abundance, while scATAC-seq focuses on open chromatin regions, helping our understanding of regulatory elements. 

Despite the recent advancements in experimental methods that allow for simultaneous measurement of multiple omics modalities at single-cell resolution, most existing datasets only include one modality, presenting challenges for multi-omics integration. A significant issue in the integration of single-modality datasets is that these omics layers have different feature spaces; for scRNA-seq, they are genes while for scATAC-seq, they are peaks corresponding to open-chromatin regions. Therefore they cannot be directly compared. 

However, integration of single-modality data, especially between scRNA-seq and scATAC-seq, allows researchers to identify cell-specific regulatory networks, uncover new cell clusters, and reveal potential biomarkers while taking advantage of the pre-existing single-modality datasets. Thus, growing number of computational tools have been developed to facilitate this process by aligning datasets from two different modalities into a unified latent space. 

In this project, I benchmark four major computational tools developed for scRNA-seq and scATAC-seq integration(Seurat, LIGER, bindSC, and GLUE) across multiple datasets and conditions to evaluate their ability to align the two modalities. Moreover, I will discuss possible ways in which these methods could be improved. 

## Project Walkthrough

### Overview of Benchmarking Strategy

In order to benchmark the performance of these integration algorithms, I used publicly available multimodal datasets that simultaneously profiled gene expression and chromatin accessibility. Then, I treat the datasets for two different modalities as originating from two different single-modality experiments and integrate them using the algorithms. Since these were originally sampled from the same cells, we have the ground truth for cell-to-cell correspondence that allows us to measure the accuracy of the alignment. 

I then visualized the coembedded space generated by each algorithm by Uniform Manifold Approximation and Projection(UMAP) and colored each cell by the original omics type to confirm that each method had successfully mixed the two omics. To quantitvely measure the alignment accuracy of the two modalities, I used FOSCTTM(fraction of cells closer than the true match) which was first introduced by [Liu et al. 2019](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8496402/). FOSCTTM measures alignment by first calculating the distance matrix beween the data points originating from scRNA-seq and scATAC-seq in the coembedded space. Then, we calculate the proportion of cells of different modality that are closer to the cell than the ground truth-matched cells and take average across all cells measured. 

Let $N$ be the number of cells in each modality and $x$ and $y$ represent the coordinates of cells originating from scRNA-seq and scATAC-seq, respectively. Then, FOSCTTM is

$$FOSCTTM = \frac{1}{N}\left(\sum_{i=1}^N\frac{n_{1, i}}{N}+\sum_{i=1}^{N}\frac{n_{2, i}}{N}\right)$$

where $n_{1, i}$ and $n_{2, i}$ are the number of cells from the other omics that were closer to the cell than the paried cell in the coembedded space. 

### Data Availability

The PBMC dataset used in this project can be downloaded directly from the [10X genomics website](https://www.10xgenomics.com/datasets/pbmc-from-a-healthy-donor-granulocytes-removed-through-cell-sorting-10-k-1-standard-1-0-0). The GTF file used to integrate in scGLUE for this data can also be downloaded from the [10X genomics website](https://www.10xgenomics.com/support/software/cell-ranger/latest/tutorials/cr-tutorial-mr)

The Pancreas dataset used in this project can be downloaded from the [ENCODE project website](https://www.encodeproject.org/) with accession: ENCSR033MDU, ENCSR158DQA, ENCSR233SQG, and ENCSR316WAS. The GTF fiile used was downloaded from [GENCODE(GCh38.p12)](https://www.gencodegenes.org/human/release_29.html)

Finally, the bulk RNA-seq and DNase-seq data analyzed was downloaded from the ENCODE project website as well accessions listed in `accession.txt`

### Pre-processing

All data was initially stored as a Seurat object and filtered based on QC metrics as shown below
```
QC <- function(seurat.obj){
  seurat.obj <- subset(
    x = seurat.obj,
    subset = nCount_ATAC < 7e4 &
      nCount_ATAC > 5e3 &
      nCount_RNA < 25000 &
      nCount_RNA > 1000 &
      percent.mt < 20
  )
  return(seurat.obj)
}
```
`percent.mt` denotes the percentage of reads in scRNA-seq that map to mitochondrial genes. Cells with higher percentage tends to be low-quality or dying cells. After filtering low-quality cells, the data was exported into suitable formats for each algorithm. To run scGLUE, I converted the Seurat object into AnnData object. Then, I ran each algorithm according to the process mentioned in its instructions. 

All four algorithms perform feature selection through choosing 2000 highly variable genes by default. I ran the four algorithms with different number of variable genes from 500 to 4000 and compared their relative performance to assess how the number of features affect the performance of each method. Moreover, to assess how the sample size affects each algorithm, a smaller subset of each data was generated by sampling without replacement as shown below:

Seurat, Liger, bindSC:
```
getSubsample <- function(seurat.obj, k) {
  
  # calculate number of cells in original dataset
  num.cells <- length(Cells(seurat.obj))
  # calculate hte number of cells for the 1/kth sample
  subsample.size <- num.cells %/% k
  subsample <- seurat.obj[, sample(colnames(seurat.obj), size =subsample.size, replace=F)]
  print(paste0("Subsample size: ", length(Cells(subsample))))
  return(subsample)
  
}
```

scGLUE:
```
cells = rna.obs_names
subsample_size = len(cells)//k
subsample_cells = np.random.choice(cells, size=subsample_size, replace=False)
rna = rna[subsample_cells]
atac = atac[subsample_cells]
```
### Integration
After the preprocessing step, I ran the four algorithms with various conditions as described above. All computing was done through the Joint High Performance Computing Exchange at the Johns Hopkins Bloomberg School of Public Health. Seurat, Liger, and bindSC was ran with only CPUs while scGLUE utilized a GPU. Specific code for each algoirthm is in the `methods` directory. The following are some of the UMAP visualizations of the integrated cell embeddings, colored by the original omics:

PBMC(2000 variable genes, 10531 cells, in row-major order, Seurat, Liger, GLUE, bindSC):
![PBMC](pbmc.png)
Pancreas(2000 variable genes, 22304 cells):
![Pancreas](pancreas.png)

### Benchmarking
However, GLUE takes significantly longer than the other three methods, even with the use of GPU. In the case of working with a large dataset without a GPU available, Seurat would be the best option for integration tasks. 
### Conclusion and Future Improvements

